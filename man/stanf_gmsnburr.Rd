% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stanf_gmsnburr.R
\name{stanf_gmsnburr}
\alias{stanf_gmsnburr}
\title{GMSNBurr Distribution}
\usage{
stanf_gmsnburr(vectorize = TRUE, rng = TRUE)
}
\arguments{
\item{vectorize}{logical; if TRUE, Vectorize Stan code of GMSNBurr distribution are given 
The default value of this parameter is TRUE}

\item{rng}{logical; if TRUE,  Stan code of quantile and 
random number generation of GMSNBurr distribution are given 
The default value of this parameter is TRUE}
}
\value{
\code{msnburr_lpdf} gives the log of density, \code{msnburr_cdf} gives the distribution
function, \code{gmsnburr_lcdf} gives the log of distribution function, \code{gmsnburr_lccdf} gives the complement of log ditribution function (1-msnburr_lcdf),
 and \code{gmsnburr_rng} generates random deviates.
}
\description{
To write the probability distribution function code of GMSNBurr distribution in Stan format.
This distribution will be optimal for accommodating left and right skewed data.
}
\details{
To determine the value of the probability density function of the GMSNBurr Distribution:
\deqn{f(y |\mu,\sigma,\alpha,\beta) = \ {\frac{\omega}{\sigma}}{{\frac{\alpha}{\beta}}^\beta} {\frac{\exp^{-\beta \omega {\frac{y-\mu}{\sigma}}} {1+{\frac{\beta}{\alpha}} \exp^{-\omega {\frac{y-\mu}{\sigma}}}}}{B(\alpha,\beta)}}}

Has \eqn{-\infty<y<\infty,  -\infty<\mu<\infty, \omega>0, \sigma>0, \alpha>0, \beta>0} 
and  \eqn{\omega(\alpha,\beta) = {\frac{B(\alpha,\beta)}{\sqrt(2\pi)}}{{1+{\frac{\beta}{\alpha}}}^{\alpha+\beta}}{\frac{\beta}{\alpha}}^{-\beta}}
}
\examples{
{\dontrun{
library(neodistr)
library(rstan)
#inputting data
set.seed(136)
dt <- rgmsnburr(100,0,1,0.5,0.5) # random generating MSNBurr-IIA data 
dataf <- list(
  n = 100,
  y = dt
)
#### not vector  
##Calling the function of the neo-normal distribution that is available in the package.
func_code<-paste(c("functions{",neodistr::stanf_gmsnburr(vectorize=FALSE),"}"),collapse="\n")
#define stan model code
model<-"
  data {
  int<lower=1> n;
  vector[n] y;
  }
  parameters {
  real mu;
  real <lower=0> sigma;
  real <lower=0> alpha;
  real <lower=0> beta; 
  }
  model {
  for(i in 1:n){
  y[i]~gmsnburr(mu,sigma,alpha,beta);
  }
  mu~cauchy(0,1);
  sigma~cauchy(0,2.5);
  alpha~cauchy(0,1);
  beta~cauchy(0,1);
  }
   "
#merge stan model code and selected neo-normal stan function
fit_code<-paste(c(func_code,model,"\n"),collapse="\n") 

# Create the model using stan function
fit1 <- stan(
  model_code = fit_code,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2,              # number of cores (could use one per chain)
  control = list(         #control samplers behavior
    adapt_delta=0.9
  )
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit1, pars=c("mu", "sigma", "alpha", "beta","lp__"), probs=c(.025,.5,.975))


# Vector
##Calling the function of the neo-normal distribution that is available in the package.
func_code_vector<-paste(c("functions{",neodistr::stanf_gmsnburr(vectorize=TRUE),"}"),collapse="\n")
# define stan model as vector
model_vector<-"
 data {
   int<lower=1> n;
   vector[n] y;
 }
 parameters {
   real mu;
   real <lower=0> sigma;
   real <lower=0> alpha;
   real <lower=0> beta;
 }
 model {
   y~gmsnburr(rep_vector(mu,n),sigma,alpha,beta);
   mu~cauchy(0,1);
   sigma~cauchy(0,2.5);
   alpha~cauchy(0,1);
   beta~cauchy(0,1);
 }
 "
#merge stan model code and selected neo-normal stan function
fit_code_vector<-paste(c(func_code_vector,model_vector,"\n"),collapse="\n")

# Create the model using stan function
fit2 <- stan(
  model_code = fit_code_vector,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2,              # number of cores (could use one per chain)
  control = list(         #control samplers behavior
    adapt_delta=0.9
  )
)

# Showing the estimation results of the parameters 
print(fit2, pars=c("mu", "sigma", "alpha","beta",  "lp__"), probs=c(.025,.5,.975))
}
}
}
\references{
Choir, A. S. (2020). The New Neo-Normal DDistributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
}
\author{
Achmad Syahrul Choir
}
